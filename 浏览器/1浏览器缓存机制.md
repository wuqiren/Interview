对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。

接下来从三部分来探讨浏览器的缓存机制
### 缓存策略
缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置HTTP Header来实现的。

> 强制缓存优先于协商缓存进行，若强缓存生效则直接使用强缓存，若强缓存不生效则进行协商缓存

> 协商缓存由服务器决定是否使用缓存；若协商缓存失效，那么就返回200，重新返回资源和缓存标识，再存入浏览器缓存中；若协商缓存生效则返回304，继续使用缓存。


#### 强缓存
强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要发送请求

##### Expires
Expires 是 HTTP/1.0 的产物。值代表的是服务端的时间，并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

##### Cache-Control
Cache-Control 出现于 HTTP/1.1，优先级高于 Expires 。该属性值表示资源会在 多少秒后过期，需要再次请求。

Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令，多个指令之间可以通过","分隔。

max-age 指令 给出了缓存过期的相对时间，单位为秒数。时间是相对于请求的时间。

s-maxage指令 与 max-age 不同之处在于，其只适用于公共缓存服务器，比如资源从源服务器发出后又被中间的代理服务器接收并缓存。当使用 s-maxage 指令后，公共缓存服务器将直接忽略 Expires 和 max-age指令的值。

public 指令表示该资源可以被任何节点缓存（包括客户端和代理服务器）

private 指令表示该资源只提供给客户端缓存，代理服务器不会进行缓存。同时当设置了 private 指令后 s-maxage 指令将被忽略。

no-store 不缓存任何响应 

no-cache 资源被缓存，但是立即失效，下次会发起请求验证资源是否过期

###### no-cache、no-store 的区别
no-cache 和 no-store 这两个指令在请求和响应中都可以使用

no-store 是真正的不进行任何缓存，告知服务器和缓存服务器，我请求、响应的内容里有机密信息；

当 no-cache 在请求头中被使用时，表示强制使用协商缓存

当 no-cache 在响应头中被返回时，表示缓存服务器不能对资源进行缓存，客户端可以缓存资源，但每次使用缓存资源前都必须先向服务器确认其有效性


#### 协商缓存
如果首次请求时没有Cache-Control和 Expires；或者Cache-Control 的属性设置为 no-cache 时，又或者如果缓存过期了。就需要发起请求验证资源是否有更新。向服务器发送请求时，服务器会根据这个请求的请求头里的If-Modified-Since 和 If-None-Match 来判断是否命中协商缓存，如果命中，则返回304状态码并且更新浏览器缓存有效期

协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag

##### Last-Modified 和 If-Modified-Since


Last-Modified 表示本地文件最后修改时间，发送请求时，会将当前的Last-Modified值作为If-Modified-Since 这个字段的内容，放在请求头中发送给服务器，去询问服务器在该时间后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。

但是 Last-Modified 存在一些弊端：
1 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
2 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源
因为以上这些弊端，所以在 HTTP / 1.1 出现了 ETag 。


##### ETag 和 If-None-Match
ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，服务器接收到 If-None-Match 后，会跟服务器上该资源的 ETag 进行比对，有变动的话就将新的资源发送回来。否则返回304状态码。并且 ETag 优先级比 Last-Modified 高。

![image](https://user-images.githubusercontent.com/54806027/208287025-e3035e47-0fde-4231-96b7-01a473591cb2.png)

##### 协商缓存两属性对比
在精准度上，ETag优于Last-Modified。由于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况：在上面也提到Last-Modified的弊端:

编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。

Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。


在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值。
另外，如果两种方式都支持的话，服务器会优先考虑ETag。

#### 启发式缓存 （如果什么缓存策略都没设置，那么浏览器会怎么处理？）

在资源请求的响应头中没有出现Expires 和 cache-control:max-age 字段值, 并且没有限制no-store，并且设置了Last-Modified, 那么浏览器默认会采用一个启发式的强缓存算法。
通常会根据响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。


#### 用户行为对浏览器缓存的影响
打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。

普通刷新 (F5)：不使用强缓存，会判断协商缓存；且因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。

强制刷新 (Ctrl + F5)：浏览器不使用缓存，服务器直接返回 200 和最新内容


#### 实际场景应用

###### 频繁变动的资源
对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

###### 代码文件
这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。

一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 Cache-Control: max-age=31536000，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。

### 缓存位置

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络
1 Service Worker
2 Memory Cache
3 Disk Cache
4 Push Cache
5 网络请求

#### Service Worker
Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

#### Memory Cache

Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
内存缓存这么高效，我们是不是能让数据都存放在内存中呢？
先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 JSS、HTML、CSS、图片等等。但是浏览器会把哪些文件丢进内存这个过程就很玄学了，我查阅了很多资料都没有一个定论。

当然，我通过一些实践和猜测也得出了一些结论：

对于大文件来说，大概率是不存储在内存中的，反之优先
当前系统内存使用率高的话，文件优先存储进硬盘

#### Disk Cache
Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。

#### Push Cache
Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。

在Chrome106版本后不可用；

