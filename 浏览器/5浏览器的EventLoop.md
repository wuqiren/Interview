
页面中大部分的任务都是在主线程上执行的，这些任务包括了

1 渲染事件(解析DOM，计算布局，绘制)

2 用户交互事件(鼠标点击，滚动页面，放大缩小)

3 JavaScript脚本执行事件

4 网络请求完成，文件读写事件

为了协调这些任务有条不絮在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列，然后主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务，我们把这些消息队列的任务成为宏任务

实际实现过程中循环采用的是系统级中断机制，也就是有事件时，线程才会被激活，没事件时，线程就会被挂起 所以并不会死循环卡死整个主线程 当没有任务执行时，主线程进入挂起状态，消耗资源极少。 当事件队列中有事件时，通过系统的信号中断来唤醒主线程并执行事件

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前

我们知道当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。


我们先来看看微任务是怎么产生的？在现代浏览器里面，产生微任务有两种方式。第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。


如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。

微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。

在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。

常见的微任务有process.nextTick 、queueMicrotask、promise.then 、MutationObserver，其中 process.nextTick 为 Node 独有。

宏任务包括 script 、 setTimeout 、setInterval 、setImmediate 、I/O 及 UI rendering。

总结：
1、微任务就是一个需要异步执行的函数，执行时机在当前主函数结束之后（同步代码之后），当前宏任务结束之前。 
2、js执行时,v8会创建一个全局执行上下文，在创建上下文的同时，v8也会在内部创建一个微任务队列，在当前宏任务执行的过程，新创建的微任务会添加到当前微任务队列中。 
3、宏任务和微任务是绑定的，每个宏任务都会创建自己的微任务队列，在当前js即将执行完时、js引擎准备退出执行上下文、清空本次调用栈时，此时引擎会检查微任务队列列表，然后按照顺序执行任务。 
4、宏任务的执行时长=宏任务的执行时间+全部微任务的执行时间，所以要注意控制微任务的执行时间。
5、dom监听的方法MutationObserver，MutationObserver 是用来监听 DOM 变化的一套方法，MutationObserver 的响应函数式异步调用的，每次dom变化，引擎会把当前的变化封装成一个异步微任务，在当前宏任务代码执行完毕时调用MutationObserver 响应函数一次返给监听者