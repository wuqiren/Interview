页面中大部分的任务都是在主线程上执行的，这些任务包括了

1 渲染事件(解析DOM，计算布局，绘制)

2 用户交互事件(鼠标点击，滚动页面，放大缩小)

3 JavaScript脚本执行事件

4 网络请求完成，文件读写事件

为了协调这些任务有条不絮在主线程上执行，页面进程引入了消息队列和时间循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列，然后主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务，我们把这些消息队列的任务成为宏任务



微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前


我们先来看看微任务是怎么产生的？在现代浏览器里面，产生微任务有两种方式。第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。


如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。