https://zh-hans.reactjs.org/docs/getting-started.html
react文档

### 为什么使用框架而不是原生
使用成熟的框架可以避免自己写大量重复的基础代码，这样就保证了项目开发的效率，另外目前大量的机构维护的框架在兼容性和安全性都做了完善的考虑和迭代支持这样那样的api实现的功能，虽然我们个人也能用全局自定义Api来实现但是个人对兼容性的考虑和对安全性的考虑肯定是比不过一个团队的。所以综合考虑无论是从开发效率还是到后期维护再到系统的安全和稳定性来说都应该优先考虑使用框架，但是技术能力和底层原理不能丢，不然时间长了就成为工具人了

框架的好处

1 组件化，特别是React，高度组件化可以让我们的项目容易维护和组合扩展

2 原生的代码 JQ时代的代码很多是面条耦合，现代框架无论是MVC，MVP还是MVVM都能够帮助我们进行分层，代码解耦更易于读写

3 生态 现在主流的前端框架都自带生态的，不管是数据流管理架构还是UI库都有成熟的方案

4 开发效率  现代前端框架都默认自动更新DOM，而非我们手动操作，解放了开发者的手动DOM的成本，提高了开发效率，从根本上解决UI和状态的问题

### react的生命周期(不用了)
生命周期是贯穿在一个组件的创建，更新，销毁中的，正好是一个组件从出现到消失的整个过程，因此被形象地成为生命周期

https://zh-hans.reactjs.org/docs/react-component.html#constructor
##### 挂载阶段
###### constructor()
###### static getDerivedStateFromProps()
###### render()
如果 shouldComponentUpdate() 返回 false，则不会调用 render()。

###### componentDidMount()
##### 更新阶段
###### static getDerivedStateFromProps()
###### shouldComponentUpdate()
###### render()
###### getSnapshotBeforeUpdate()
###### componentDidUpdate()
componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法。

##### 卸载阶段
###### componentWillUnmount()





##### 错误处理
当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：

static getDerivedStateFromError()
componentDidCatch()














### redux和mobx的区别

redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中

redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作

redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改

mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用

mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易

基于以上区别,我们可以简单得分析一下两者的不同使用场景.
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于redux不可变的特性，天然支持这些操作.
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用mobx作为组件局部状态管理器来用.

