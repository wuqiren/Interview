https://juejin.cn/post/7166870049066582053

### HTTP 和HTTPS

#### HTTP 与 HTTPS 区别
加密： HTTPS 是 HTTP 协议的更加安全的版本，通过使用SSL/TLS进行加密传输的数据；
连接方式： HTTP（三次握手）和 HTTPS （三次握手+数字证书）连接方式不一样；
端口： HTTP 默认的端口是 80和 HTTPS 默认端口是 443


##### 301 和 302 哪个对 seo 更友好（301）

网站优化中，经常会面临网站链接修改或改变的事情，其中一个解决办法就是使用网站跳转的方式，处理变化的链接，下面讲述301和302跳转对SEO的影响。

##### 301(永久移动)

请求的网页已被永久移动到新位置。服务器返回此响应(作为对GET或HEAD请求的响应)时，会自动将请求者转到新位置。使用此代码可通知搜索引擎蜘蛛，某个网页或网站已被永久移动到新位置。

##### 302(临时移动)

服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应GET和HEAD请求的301代码类似，会自动将请求者转到不同的位置。但由于搜索引擎蜘蛛会继续抓取原有位置并将其编入索引，因此某个页面或网站已被移动时，不要使用此代码来通知搜索引擎蜘蛛。

怎么理解301和302跳转

跳转使用情况：假如原先有个页面的地址是http://www.xxxx.com/A.htm（下面简称A页面），现在因业务需要设置成http://www.xxxx.com/B.htm（下面简称B页面），虽然对于访问者来说没有任何区别，但是对于搜索引擎来说，由于A页面和B页面是不同的页面，所以我们需要告诉搜索引擎，B页面就是原来的A页面，这时就需要使用跳转的方式来处理，可以需要选择301或者302，他们的区别在于：

使用301表示永久性跳转，如果A页面已经被搜索引擎收录了，那么搜索引擎会知道以后再也没有A页面这个页面了，它已经转移到B页面上去了，搜索引擎会把原来对于A页面的排名权重转移到B页面上去，平稳过渡，然后在搜索引擎的数据库中删除A页面，替换成B页面。

使用302表示暂时性跳转，302与301的区别在于，搜索引擎的数据库不会删除A页面，但仍会增加B页面。

##### 不使用301、302的后果

如果网站管理员修改了页面链接，将A页面改成了B页面，但是没有在服务器上设置跳转属性（IIS、Apache、Websphere等等），那么虽然对于用户访问是没有影响，但是搜索引擎并不知道，会导致两个不好的结果：

它仍然会试图去访问原来的A页面（有两种可能：1.搜索引擎数据库还没有更新，仍然保留着A页面，因此会去访问。2.外面有些网站的友情链接仍然是A页面，搜索引擎爬到之后就仍然去访问A页面），结果发现成了404状态，由于404表示网站出错，搜索引擎认为网站没有做好，因此就会给予网站惩罚，网站的排名就会下降。

过了一段时间，搜索引擎发现了网站多了一个B页面，并进行了收录，但是由于没有设置跳转，因此它认为这是全新的页面，跟原来的A页面没有关系，原来A页面的排名就不会传导给B页面，B页面就要重新开始排名的计算，一般来说需要3个月左右，假如A页面原来的排名不错，那B页面重新开始计算，就会非常吃亏。

301、302使用不当的后果

从表面上看，302比301更友好，但因为302是暂时性跳转的含义，如果被用来做长期跳转，搜索引擎就会认为这是网站在利用302跳转转移A页面的权重，为B页面作弊，就会给予网站惩罚。由于搜索引擎对于跳转时间判断规则的不确定，因此不建议使用302跳转。

Google一直强调使用301，而不要用302。
#### HTTP长链接原理
HTTP属于 TCP/IP模型中的应用层协议，HTTP长连接和HTTP短连接，指的是传输层的TCP连接是否被多次使用。
默认情况下，HTTP的1.0版本协议中，HTTP在每次请求结束后都会主动释放TCP连 接，因此HTTP连接是一种“短连接”。
HTTP的1.1版本协议中默认使用长连接而不是短连接，除非显式关闭TCP连接。如果要显式关闭连 接，需要在HTTP报文首部加上“Connection:Close”请求头，也就是说在HTTP/1.1协议 中，默认情况下，所有的TCP连接都可以进行复用的

长链接的协议就 Connection：Keep-Alive


  HTTP长连接，也叫HTTP持久连接，指的是TCP连接建立后，该传输层连接不再进行释放，供应用层反复使用。
#### HTTP中的Keep-Alive

HTTP 持久连接（HTTP persistent connection，也称作 HTTP keep-alive 

HTTP 协议采用 “请求 - 应答” 模式，当使用普通模式，即非 KeepAlive 模式时，每个请求 / 应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP 协议为无连接的协议），每次请求都会经过三次握手四次挥手过程，效率较低；当使用Keep-Alive模式时，客户端到服务器端的连接不会断开，当出现对服务器的后继请求时，客户端就会复用已建立的连接。
![image](https://user-images.githubusercontent.com/54806027/208593443-d71ef474-1ddb-45d0-8374-7f37ccf72eff.png)

>HTTP/1.0中默认使用Connection: close。在HTTP/1.1中已经默认使用Connection: keep-alive。
通过对比可以看出，Keep-Alive模式更加高效，因为避免了连接建立和释放的开销。但是，如果一个连接是不会断开的，那么多个请求之间如何进行区分呢？也就是说浏览器是如何知道当前请求已经完成了呢？为了解决这个问题，HTTP对header中又添加了一个Content-Length字段。

##### Content-Length
Content-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。
所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置Content-Length来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，Content-Length就无法解决上面的问题，这个时候就需要用到Transfer-Encoding字段。

##### Transfer-Encoding
Transfer-Encoding是指传输编码，还有一个类似的字段叫做：Content-Encoding。两者的区别是Content-Encoding用于对实体内容的压缩编码，比如Content-Encoding: gzip；Transfer-Encoding则改变了报文的格式，比如上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定Transfer-Encoding: chunked来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定Transfer-Encoding: gzip, chunked表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。

##### Keep-Alive优点
节省了服务端 CPU 和内存适用量
降低拥塞控制 （TCP 连接减少）
减少了后续请求的延迟（无需再进行握手）
##### Keep-Alive缺点

对于某些低频访问的资源 / 服务，比如一个冷门的图片服务器，一年下不了几次，每下一次连接还保持就比较浪费了（这个场景举的不是很恰当）。Keep-Alive 可能会非常影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间，额外占用了服务端的连接数。

##### Http 连接复用后怎样断开连接

###### 通过 Keep-Alive Timeout 标识

现在在服务端设置响应 Header:
Keep-Alive:timeout=15

##### 通过 Connection close 标识
是接收端通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。

#### http请求可以怎么拦截 

如果恶意请求有特征，对付起来很简单：直接拦截它就行了。

HTTP 请求的特征一般有两种：IP 地址和 User Agent 字段。比如，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。

拦截可以在三个层次做。


##### 1 专用硬件

Web 服务器的前面可以架设硬件防火墙，专门过滤请求。这种效果最好，但是价格也最贵。

##### 2 本机防火墙

操作系统都带有软件防火墙，Linux 服务器一般使用 iptables。比如，拦截 IP 地址1.2.3.4的请求，可以执行下面的命令。

iptables -A INPUT -s 1.2.3.4 -j DROP

##### 3 Web 服务器
nginx 的写法如下。
location / {
  deny 1.2.3.4;
}

